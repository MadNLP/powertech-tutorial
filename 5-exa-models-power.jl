
# # Tutorial 5: solving the optimal power flow with ExaModelsPower.jl
#
# In the previous tutorials, we have seen how to implement power flow equations and
# optimal power flow using ExaModels.jl. In this tutorial, we will see how to
# use the off-the-shelf modeling library ExaModelsPower.jl to create optimal power flow
# models, and how to solve them with GPUs.
#
# ## What is ExaModelsPower.jl?
# ExaModelsPower.jl can model OPF problems using the ExaModels package to generate models that can be solved using either CPU or GPU. This tutorial will demonstrate how ExaModelsPower.jl can be leveraged to solve different versions of OPF. Currently, all models generated by ExaModelsPower represent the full, AC version of the OPF formulation without any modifications (e.g, convex relaxations). 

# ## Getting started
# ExaModelsPower.jl package can be installed via
# ```julia
# using Pkg
# Pkg.add(url="https://github.com/exanauts/ExaModelsPower.jl.git")
# ```
# We will start by importing the necessary packages. 

using ExaModelsPower, CUDA, MadNLPGPU

# ExaModelsPower.jl provides a set of functions to create power flow models, CUDA.jl provides the GPU backend, and MadNLPGPU.jl provides the solver interface to solve the models on GPUs.

# ## Static optimal power flow
# We will begin by constructing and solving a static OPF using the function opf_model. A static OPF problem can be created by the following one-liner:
model, vars, cons = opf_model(
    "pglib_opf_case118_ieee.m";
    backend = CUDABackend(),
    form = :polar,
    T = Float64
)
# For the static OPF, the only input required is the filename for the OPF matpower file. The file does not need to be locally installed, and it will be automatically downloaded from __[pglib-opf repository](https://github.com/power-grid-lib/pglib-opf)__ if the file is not found in the user's data depot path. If keyword `T` is not specified, the numerical type will default to Float64. The `backend` defaults to nothing (used on CPU) and the form will default to polar coordinates. Here, we use `CUDABackend()` to create the problem on an NVIDIA GPU, and `form = :polar` to specify that the voltage angles will be represented in polar coordinates. The function returns a tuple containing the model, the variables, and the constraints.

# Once the model is built, we can solve it using the `madnlp` function from MadNLPGPU.jl. 
result = madnlp(model; tol=1e-6)

# Once a solution has been generated, the values of any of the variables in the model can be unpacked using the vars NamedTuple
using ExaModels
solution(result, vars.vm)

# Result also stores the objective value
result.objective

# ExaModelsPower supports solving the OPF in either polar or rectangular coordinates. For example, to create a rectangular OPF model, we can simply change the `form` keyword argument to `:rectangular`:
model, vars, cons = opf_model(
    "pglib_opf_case118_ieee.m";
    form = :rect
)

# ExaModelsPower supports any nonlinear optimization solver available within the [Julia Smooth Optimizer](https://jso.dev/) ecosystem. For example,
using NLPModelsIpopt
result = ipopt(model; tol=1e-6)

# ## Other features
# ExaModelsPower.jl is currently under active development. We are currently implementing the following formulations:
# - Multi-period OPF (with ramping constraints and/or storage)
# - Security-constrained OPF (with N-1 constraints)
# - Distribution system OPF (with unbalanced three-phase models)

# For more information on the current status of ExaModelsPower.jl, please refer to the __[ExaModelsPower.jl documentation](https://exanauts.github.io/ExaModelsPower.jl/latest/)__.
